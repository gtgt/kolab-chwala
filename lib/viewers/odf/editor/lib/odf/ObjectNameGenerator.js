/**
 * @license
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * The JavaScript code in this page is free software: you can redistribute it
 * and/or modify it under the terms of the GNU Affero General Public License
 * (GNU AGPL) as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.  The code is distributed
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU AGPL for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this code.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As additional permission under GNU AGPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * As a special exception to the AGPL, any HTML file which merely makes function
 * calls to this code, and for that purpose includes it by reference shall be
 * deemed a separate work for copyright law purposes. In addition, the copyright
 * holders of this code give you permission to combine this code with free
 * software libraries that are released under the GNU LGPL. You may copy and
 * distribute such a system following the terms of the GNU AGPL for this code
 * and the LGPL for the libraries. If you modify this code, you may extend this
 * exception to your version of the code, but you are not obligated to do so.
 * If you do not wish to do so, delete this exception statement from your
 * version.
 *
 * This license applies to this entire compilation.
 * @licend
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global odf, runtime, core, Node*/

runtime.loadClass("core.DomUtils");
runtime.loadClass("core.Utils");

/**
 * Helper object for generating unique object names. Each name is only reported once per instance,
 * irrespective of whether it is actually then inserted into the dom tree in the odfContainer.
 *
 * There is expected to be a single instance of the object name generator created per session. This is necessary
 * to close a potential race condition when generating unique names for operations. As there is no guarantee
 * when a given op is executed, it is insufficient to simply rely on all previously generated names to be now present
 * in the document definitions. To cope with this, the names generated by this instance are also cached for
 * the lifetime of this object.
 *
 * Failure to do this could result in a situation like the following
 * 1. SessionController generates new OpAddStyle & adds to session's queue
 * 2. SessionController generates another OpAddStyle & adds to session's queue
 *
 * At step 2, as the session's queue implementation has no requirement that it immediately executes the operation from
 * step 1, it is likely that the style created in step 1 is not yet present in the document DOM.
 *
 * @param {!odf.OdfContainer} odfContainer
 * @param {!string} memberId
 * @constructor
 */
odf.ObjectNameGenerator = function ObjectNameGenerator(odfContainer, memberId) {
    "use strict";
    var stylens = odf.Namespaces.stylens,
        drawns = odf.Namespaces.drawns,
        xlinkns = odf.Namespaces.xlinkns,
        domUtils = new core.DomUtils(),
        utils = new core.Utils(),
        memberIdHash = utils.hashString(memberId),
        styleNameGenerator = null,
        frameNameGenerator = null,
        imageNameGenerator = null,
        existingFrameNames = {},
        existingImageNames = {};

    /**
     * @param {!string} prefix Prefix to use for unique name generation
     * @param {!function():!Object.<string, !boolean>} findExistingNames
     * @constructor
     */
    function NameGenerator(prefix, findExistingNames) {
        var reportedNames = {};
        /**
         * Generate a unique name
         * @returns {!string}
         */
        this.generateName = function () {
            var existingNames = findExistingNames(),
                startIndex = 0,
                name;
            do {
                name = prefix + startIndex;
                startIndex += 1;
            } while (reportedNames[name] || existingNames[name]);
            reportedNames[name] = true;
            return name;
        };
    }

    /**
     * Get all the style names defined in the style:style elements of the current document including automatic styles
     *
     * @returns {!Object.<string, !boolean>}
     */
    function getAllStyleNames() {
        var styleElements = [odfContainer.rootElement.automaticStyles, odfContainer.rootElement.styles],
            node,
            styleNames = {};

        styleElements.forEach(function (styleListElement) {
            node = styleListElement.firstChild;
            while (node) {
                if (node.nodeType === Node.ELEMENT_NODE && node.namespaceURI === stylens && node.localName === "style") {
                    styleNames[node.getAttributeNS(stylens, 'name')] = true;
                }
                node = node.nextSibling;
            }
        });
        return styleNames;
    }

    /**
     * Generate a unique style name across the style:style elements
     * @returns {!string}
     */
    this.generateStyleName = function () {
        if (styleNameGenerator === null) {
            styleNameGenerator = new NameGenerator(
                "auto" + memberIdHash + "_",
                function () {
                    // TODO: can cache the existing names once we fix the todo in formatting.applyStyle
                    return getAllStyleNames();
                }
            );
        }
        return styleNameGenerator.generateName();
    };
    /**
     * Generate a unique frame name
     * @returns {!string}
     */
    this.generateFrameName = function () {
        if (frameNameGenerator === null) {
            var nodes = domUtils.getElementsByTagNameNS(odfContainer.rootElement.body, drawns, 'frame');
            nodes.forEach(function (frame) {
                existingFrameNames[frame.getAttributeNS(drawns, 'name')] = true;
            });

            frameNameGenerator = new NameGenerator(
                "fr" + memberIdHash + "_",
                function () {
                    return existingFrameNames;
                }
            );
        }
        return frameNameGenerator.generateName();
    };
    /**
     * Generate a unique image name
     * @returns {!string}
     */
    this.generateImageName = function () {
        if (imageNameGenerator === null) {
            var nodes = domUtils.getElementsByTagNameNS(odfContainer.rootElement.body, drawns, 'image');
            nodes.forEach(function (image) {
                var path = image.getAttributeNS(xlinkns, 'href');
                path = path.substring("Pictures/".length, path.lastIndexOf('.'));
                existingImageNames[path] = true;
            });

            imageNameGenerator = new NameGenerator(
                "img" + memberIdHash + "_",
                function () {
                    return existingImageNames;
                }
            );
        }
        return imageNameGenerator.generateName();
    };
};
